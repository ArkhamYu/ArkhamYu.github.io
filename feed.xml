<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://arkhamyu.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://arkhamyu.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-11-18T20:08:59+00:00</updated><id>https://arkhamyu.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">The Quantum Echoes algorithm breakthrough</title><link href="https://arkhamyu.github.io/blog/2025/the-quantum-echoes-algorithm-breakthrough/" rel="alternate" type="text/html" title="The Quantum Echoes algorithm breakthrough"/><published>2025-10-22T00:00:00+00:00</published><updated>2025-10-22T00:00:00+00:00</updated><id>https://arkhamyu.github.io/blog/2025/the-quantum-echoes-algorithm-breakthrough</id><content type="html" xml:base="https://arkhamyu.github.io/blog/2025/the-quantum-echoes-algorithm-breakthrough/"><![CDATA[<p>Oct 22, 2025 Our Willow quantum chip demonstrates the first-ever algorithm to achieve verifiable quantum advantage on hardware. Editor’s note: Today, we’re announcing research that shows — for the first time in history — that a quantum computer can successfully run a verifiable algorithm on hardware, surpassing even the fastest classical supercomputers (13,000x faster). It can compute the structure of a molecule, and paves a path towards real-world applications. Today’s advance builds on decades of work, and six years of major breakthroughs. Back in 2019, we demonstrated that a quantum computer could solve a problem that would take the fastest classical supercomputer thousands of years. Then, late last year (2024), our new Willow quantum chip showed how to dramatically suppress errors, solving a major issue that challenged scientists for nearly 30 years. Today’s breakthrough moves us much closer to quantum computers that can drive major discoveries in areas like medicine and materials science.Imagine you’re trying to find a lost ship at the bottom of the ocean. Sonar technology might give you a blurry shape and tell you, “There’s a shipwreck down there.” But what if you could not only find the ship but also read the nameplate on its hull?That’s the kind of unprecedented precision we’ve just achieved with our Willow quantum chip. Today, we’re announcing a major algorithmic breakthrough that marks a significant step towards a first real-world application. Just published in Nature, we have demonstrated the first-ever verifiable quantum advantage running the out-of-order time correlator (OTOC) algorithm, which we call Quantum Echoes.Quantum Echoes can be useful in learning the structure of systems in nature, from molecules to magnets to black holes, and we’ve demonstrated it runs 13,000 times faster on Willow than the best classical algorithm on one of the world’s fastest supercomputers.In a separate, proof-of-principle experiment Quantum computation of molecular geometry via many-body nuclear spin echoes (to be posted on arXiv later today), we showed how our new technique — a “molecular ruler” — can measure longer distances than today’s methods, using data from Nuclear Magnetic Resonance (NMR) to gain more information about chemical structure.This is the first time in history that any quantum computer has successfully run a verifiable algorithm that surpasses the ability of supercomputers. Quantum verifiability means the result can be repeated on our quantum computer — or any other of the same caliber — to get the same answer, confirming the result. This repeatable, beyond-classical computation is the basis for scalable verification, bringing quantum computers closer to becoming tools for practical applications.Our new technique works like a highly advanced echo. We send a carefully crafted signal into our quantum system (qubits on Willow chip), perturb one qubit, then precisely reverse the signal’s evolution to listen for the “echo” that comes back.This quantum echo is special because it gets amplified by constructive interference — a phenomenon where quantum waves add up to become stronger. This makes our measurement incredibly sensitive.This diagram shows the four-step process for creating a quantum echo on our 105-qubit array: run operations forward, perturb one qubit, run operations backward, and measure the result. The signal’s overlap reveals how a disturbance spreads across the Willow chip.This implementation of the Quantum Echoes algorithm is enabled by the advances in quantum hardware of our Willow chip. Last year, Willow proved its power with our Random Circuit Sampling benchmark, a test designed to measure maximum quantum state complexity. The Quantum Echoes algorithm represents a new class of challenge because it models a physical experiment. This means this algorithm tests not only for complexity, but also for precision in the final calculation. This is why we call it “quantum verifiable,” meaning the result can be cross-benchmarked and verified by another quantum computer of similar quality. To deliver both precision and complexity, the hardware must have two key traits: extremely low error rates and high-speed operations.Quantum computers will be instrumental in modeling quantum mechanical phenomena, such as the interactions of atoms and particles and the structure (or shape) of molecules. One of the tools scientists use to understand chemical structure is Nuclear Magnetic Resonance (NMR), the same science behind MRI technology. NMR acts as a molecular microscope, powerful enough to let us see the relative position of atoms, which helps us understand a molecule’s structure. Modeling molecules’ shape and dynamics is foundational in chemistry, biology and materials science, and advances that help us do this better underpin progress in fields ranging from biotechnology to solar energy to nuclear fusion.In a proof-of-principle experiment in partnership with The University of California, Berkeley, we ran the Quantum Echoes algorithm on our Willow chip to study two molecules, one with 15 atoms and another with 28 atoms, to verify this approach. The results on our quantum computer matched those of traditional NMR, and revealed information not usually available from NMR, which is a crucial validation of our approach.Just as the telescope and the microscope opened up new, unseen worlds, this experiment is a step toward a ‘quantum-scope’ capable of measuring previously unobservable natural phenomena. Quantum computing-enhanced NMR could become a powerful tool in drug discovery, helping determine how potential medicines bind to their targets, or in materials science for characterizing the molecular structure of new materials like polymers, battery components or even the materials that comprise our quantum bits (qubits).This demonstration of the first-ever verifiable quantum advantage with our Quantum Echoes algorithm marks a significant step toward the first real-world applications of quantum computing.As we scale up towards a full-scale, error-corrected quantum computer, we expect many more such useful real-world applications to be invented. Now, we’re focused on achieving Milestone 3 on our quantum hardware roadmap, a long-lived logical qubit.Let’s stay in touch. Get the latest news from Google in your inbox. Follow Us</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Our latest quantum breakthrough, Quantum Echoes, offers a path toward unprecedented scientific discoveries and analysis.]]></summary></entry><entry><title type="html">Note 1: Stabilizer and XP Formalisms</title><link href="https://arkhamyu.github.io/blog/2025/stab-xp-formalism/" rel="alternate" type="text/html" title="Note 1: Stabilizer and XP Formalisms"/><published>2025-03-26T00:00:00+00:00</published><updated>2025-03-26T00:00:00+00:00</updated><id>https://arkhamyu.github.io/blog/2025/stab-xp-formalism</id><content type="html" xml:base="https://arkhamyu.github.io/blog/2025/stab-xp-formalism/"><![CDATA[<h2 id="stabilizer-formalism">Stabilizer formalism</h2> <figure> <img src="/assets/img/qec/stabformalism.png" alt="Repetition code circuit used to illustrate the stabilizer formalism and measurement constraints." style="max-width: 100%;"/> <figcaption><strong>Figure 1.</strong> Repetition code circuit used to illustrate the stabilizer formalism and measurement constraints.</figcaption> </figure> <h3 id="example-stabilizer-analysis-of-the-circuit-in-fig-1">Example: stabilizer analysis of the circuit in Fig. 1</h3> <p>Label the qubits from top to bottom as (q_1, q_2, q_3, q_4, q_5).<br/> The initial state is \(\ket{0}_{1} \otimes \big(a\ket{000} + b\ket{111}\big)_{2,3,4} \otimes \ket{0}_{5},\) whose stabilizer group is generated by \(\mathcal{S}_0 = \langle Z_1,\; Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 \rangle .\)</p> <p>Recall the conjugation action of a CNOT gate (\mathrm{CX}_{c \to t}) on single-qubit Pauli operators (ignoring global phases): \(\begin{aligned} X_c &amp;\mapsto X_c X_t, &amp;\qquad Z_c &amp;\mapsto Z_c, \\ X_t &amp;\mapsto X_t, &amp;\qquad Z_t &amp;\mapsto Z_c Z_t . \end{aligned}\) The action on multi-qubit Pauli operators follows by multiplicativity.</p> <h4 id="step-1-mathrmcxq_2-to-q_1">Step 1: (\mathrm{CX}(q_2 \to q_1))</h4> <p>Applying the above rules to each generator in (\mathcal{S}_0): \(\begin{aligned} Z_1 &amp;\mapsto Z_1 Z_2, \\ Z_5 &amp;\mapsto Z_5, \\ Z_2 Z_3 &amp;\mapsto Z_2 Z_3, \\ Z_3 Z_4 &amp;\mapsto Z_3 Z_4, \\ X_2 X_3 X_4 &amp;\mapsto (X_2 X_1) X_3 X_4 = X_1 X_2 X_3 X_4 . \end{aligned}\) Thus \(\mathcal{S}_1 = \langle Z_1 Z_2,\; Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_1 X_2 X_3 X_4 \rangle .\)</p> <h4 id="step-2-mathrmcxq_3-to-q_1">Step 2: (\mathrm{CX}(q_3 \to q_1))</h4> <p>\(\begin{aligned} Z_1 Z_2 &amp;\mapsto (Z_3 Z_1) Z_2 = Z_1 Z_2 Z_3, \\ Z_5 &amp;\mapsto Z_5, \\ Z_2 Z_3 &amp;\mapsto Z_2 Z_3, \\ Z_3 Z_4 &amp;\mapsto Z_3 Z_4, \\ X_1 X_2 X_3 X_4 &amp;\mapsto X_1 \cdot (X_3 X_1) \cdot X_2 X_4 = X_2 X_3 X_4 . \end{aligned}\) Thus \(\mathcal{S}_2 = \langle Z_1 Z_2 Z_3,\; Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 \rangle .\)</p> <h4 id="step-3-mathrmcxq_3-to-q_5">Step 3: (\mathrm{CX}(q_3 \to q_5))</h4> <p>\(\begin{aligned} Z_1 Z_2 Z_3 &amp;\mapsto Z_1 Z_2 Z_3, \\ Z_5 &amp;\mapsto Z_3 Z_5, \\ Z_2 Z_3 &amp;\mapsto Z_2 Z_3, \\ Z_3 Z_4 &amp;\mapsto Z_3 Z_4, \\ X_2 X_3 X_4 &amp;\mapsto X_2 \cdot (X_3 X_5) \cdot X_4 = X_2 X_3 X_4 X_5 . \end{aligned}\) Thus \(\mathcal{S}_3 = \langle Z_1 Z_2 Z_3,\; Z_3 Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 X_5 \rangle .\)</p> <h4 id="step-4-mathrmcxq_4-to-q_5">Step 4: (\mathrm{CX}(q_4 \to q_5))</h4> <p>\(\begin{aligned} Z_1 Z_2 Z_3 &amp;\mapsto Z_1 Z_2 Z_3, \\ Z_3 Z_5 &amp;\mapsto Z_3 (Z_4 Z_5) = Z_3 Z_4 Z_5, \\ Z_2 Z_3 &amp;\mapsto Z_2 Z_3, \\ Z_3 Z_4 &amp;\mapsto Z_3 Z_4, \\ X_2 X_3 X_4 X_5 &amp;\mapsto X_2 X_3 (X_4 X_5) X_5 = X_2 X_3 X_4 . \end{aligned}\) Thus the final stabilizer group is \(\mathcal{S}_{\mathrm{final}} = \langle Z_1 Z_2 Z_3,\; Z_3 Z_4 Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 \rangle .\)</p> <h4 id="measurement-analysis">Measurement analysis</h4> <p>From (\mathcal{S}_{\mathrm{final}}) we obtain:</p> <ul> <li>(Z_1 = (Z_1 Z_2 Z_3)(Z_2 Z_3) \in \mathcal{S}_{\mathrm{final}})<br/> (\Rightarrow) (M_1 = Z_1) is deterministic with outcome (+1).</li> <li>(Z_5 = (Z_3 Z_4 Z_5)(Z_3 Z_4) \in \mathcal{S}_{\mathrm{final}})<br/> (\Rightarrow) (M_2 = Z_5) is deterministic with outcome (+1).</li> <li>(Z_2 Z_3 = +1) and (Z_3 Z_4 = +1) enforce (m_3 \oplus m_4 = 0) and (m_4 \oplus m_5 = 0), i.e. (m_3 = m_4 = m_5).<br/> The individual values are random, but subject to these parity constraints.</li> </ul> <p>These parity checks correspond to the two detectors ((m_3 \oplus m_4)) and<br/> ((m_4 \oplus m_5)) in the detector error model.</p> <hr/> <h2 id="the-xp-formalism">The XP formalism</h2> <p>An XP stabiliser code is defined by fixing an integer (N \geq 2), referred to as the <strong>precision</strong> of the code.<br/> We take stabiliser generators from (\langle \omega I, X, P \rangle^{\otimes n}), where \(\omega := \exp\!\Big(\frac{\pi i}{N}\Big) = \exp\!\Big(\frac{1}{2N} 2\pi i\Big), \qquad \omega^{2N} = 1,\) and \(P := \mathrm{diag}(1,\omega^2), \qquad P^N = I.\)</p> <p>Each choice of precision (N) leads to a different stabiliser formalism.<br/> For example, (N = 2) corresponds to the standard Pauli stabiliser formalism,<br/> with (\omega = i) and (Z^2 = I).</p> <p>Under conjugation by Hadamard operators, if (N = 2M) then \(HPH^{-1} = \sqrt[M]{X}.\)</p> <h3 id="vector-representation-of-xp-operators">Vector representation of XP operators</h3> <p>Let [ \mathbf{u} = (p \mid \mathbf{X} \mid \mathbf{Z}) \in \mathbb{Z}_{2N} \times \mathbb{Z}_2^n \times \mathbb{Z}_N^n ] be an integer vector of length (2n + 1).<br/> The XP operator of precision (N) corresponding to (\mathbf{u}) is \(XP_N(\mathbf{u}) := \omega^p \bigotimes_{0 \leq i &lt; n} X^{\mathbf{X}[i]} P^{\mathbf{Z}[i]} .\)</p> <p>Each component is periodic and can be rewritten as \(XP_N(p \mid \mathbf{X} \mid \mathbf{Z}) = XP_N\big(p \bmod 2N \,\big|\, \mathbf{X} \bmod 2 \,\big|\, \mathbf{Z} \bmod N\big).\)</p> <p>Some useful properties:</p> <ol> <li>The identity XP operator is (XP_N(0 \mid \mathbf{0} \mid \mathbf{0})),<br/> where (\mathbf{0}) is the length-(n) zero vector.</li> <li>Because (\omega^N = -1), we have (XP_N(N \mid \mathbf{0} \mid \mathbf{0}) = -I).</li> <li>The single-qubit (X) operator is (XP_N(0 \mid 1 \mid 0)).</li> <li>Diagonal operators are of the form (XP_N(N \mid \mathbf{0} \mid \mathbf{Z})).</li> <li>If (N) is even, the single-qubit (Z) operator is (XP_N(0 \mid 0 \mid N/2)).<br/> For odd (N), (Z) operators cannot be represented as XP operators.</li> </ol> <p>The XP formalism has a fundamental commutation relation that allows us to move (P) operators to the right of (X) operators: \(PX = \omega^2 X P^{-1}.\)</p> <p>The <strong>action of an XP operator</strong> on a computational-basis state (\ket{\mathbf{e}}),<br/> where (\mathbf{e} \in \mathbb{Z}_2^n), is \(XP_N(p \mid \mathbf{X} \mid \mathbf{Z}) \ket{\mathbf{e}} = \omega^{p + 2\mathbf{e} \cdot \mathbf{Z}} \ket{\mathbf{e} \oplus \mathbf{X}}.\)</p> <h3 id="example-an-xp-operator-at-precision-n--8">Example: an XP operator at precision (N = 8)</h3> <p>Consider \(A = XP_8(12 \mid 1110000 \mid 0040000).\)</p> <p>The <strong>precision</strong> is specified by the subscript (8), so (N = 8).<br/> Then (\omega = \exp!\big(\tfrac{1}{16} 2\pi i\big)) and (P^8 = I), so (P = T) where<br/> (T = \mathrm{diag}(1,\sqrt{i})).<br/> The overall phase of the operator is [ \omega^{12} = \exp!\Big(\frac{12}{16} 2\pi i\Big) = -i . ]</p> <p>The (X) component is a binary vector of length (n),<br/> so (\mathbf{X} \in \mathbb{Z}_2^n).<br/> In this case (\mathbf{X} = 1110000), representing (X_1 X_2 X_3).</p> <p>The (Z) component is a vector (\mathbf{Z} \in \mathbb{Z}_8^n).<br/> Here (\mathbf{Z} = 0040000), representing (T_3^4).</p> <p>Thus \(\begin{aligned} XP_8(12 \mid 1110000 \mid 0040000) &amp;= \exp\!\Big(\frac{12}{16} 2\pi i\Big)\, X_1 X_2 X_3 T_3^4 \\ &amp;= -i\, X_1 X_2 X_3 Z_3 . \end{aligned}\)</p> <p>Since the phase and (Z) components are divisible by (4),<br/> we can <strong>rescale</strong> (A) and write it as a precision-(2) operator<br/> by dividing the phase and (Z) components by (4): \(XP_8(12 \mid 1110000 \mid 0040000) = XP_4(3 \mid 1110000 \mid 0010000).\)</p>]]></content><author><name></name></author><category term="qec"/><category term="qec-notes"/><category term="stabilizer"/><category term="xp-formalism"/><summary type="html"><![CDATA[Worked example of a repetition-code circuit and a short introduction to the XP stabiliser formalism.]]></summary></entry></feed>