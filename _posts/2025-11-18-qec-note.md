---
layout: post
title: "Note 1: Stabilizer and XP Formalisms"
description: "Worked example of a repetition-code circuit and a short introduction to the XP stabiliser formalism."
tags: [qec-notes, stabilizer, xp-formalism]
categories: [qec]
published: true
thumbnail: /assets/img/qec/stabformalism.png
---

## Stabilizer formalism

![Repetition code circuit used to illustrate the stabilizer formalism and measurement constraints.](/assets/img/qec/stabformalism.png){#fig-stabformalism}

### Example: stabilizer analysis of the circuit in Fig. \ref{fig-stabformalism}

Label the qubits from top to bottom as \(q_1, q_2, q_3, q_4, q_5\).  
The initial state is
\[
\ket{0}_{1} \otimes \big(a\ket{000} + b\ket{111}\big)_{2,3,4} \otimes \ket{0}_{5},
\]
whose stabilizer group is generated by
\begin{equation}
\mathcal{S}_0 = \langle Z_1,\; Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 \rangle .
\end{equation}

Recall the conjugation action of a CNOT gate \(\mathrm{CX}_{c \to t}\) on single-qubit Pauli operators (ignoring global phases):
\begin{align}
X_c &\;\mapsto\; X_c X_t, & Z_c &\;\mapsto\; Z_c, \\
X_t &\;\mapsto\; X_t, & Z_t &\;\mapsto\; Z_c Z_t .
\end{align}
The action on multi-qubit Pauli operators follows by multiplicativity.

#### Step 1: \(\mathrm{CX}(q_2 \to q_1)\)

Applying the above rules to each generator in \(\mathcal{S}_0\):
\begin{align*}
Z_1 &\to Z_1 Z_2, \\
Z_5 &\to Z_5, \\
Z_2 Z_3 &\to Z_2 Z_3, \\
Z_3 Z_4 &\to Z_3 Z_4, \\
X_2 X_3 X_4 &\to (X_2 X_1) X_3 X_4 = X_1 X_2 X_3 X_4.
\end{align*}
Thus
\begin{equation}
\mathcal{S}_1 = \langle Z_1 Z_2,\; Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_1 X_2 X_3 X_4 \rangle .
\end{equation}

#### Step 2: \(\mathrm{CX}(q_3 \to q_1)\)

\begin{align*}
Z_1 Z_2 &\to (Z_3 Z_1) Z_2 = Z_1 Z_2 Z_3, \\
Z_5 &\to Z_5, \\
Z_2 Z_3 &\to Z_2 Z_3, \\
Z_3 Z_4 &\to Z_3 Z_4, \\
X_1 X_2 X_3 X_4 &\to X_1 \cdot (X_3 X_1) \cdot X_2 X_4 = X_2 X_3 X_4.
\end{align*}
Thus
\begin{equation}
\mathcal{S}_2 = \langle Z_1 Z_2 Z_3,\; Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 \rangle .
\end{equation}

#### Step 3: \(\mathrm{CX}(q_3 \to q_5)\)

\begin{align*}
Z_1 Z_2 Z_3 &\to Z_1 Z_2 Z_3, \\
Z_5 &\to Z_3 Z_5, \\
Z_2 Z_3 &\to Z_2 Z_3, \\
Z_3 Z_4 &\to Z_3 Z_4, \\
X_2 X_3 X_4 &\to X_2 \cdot (X_3 X_5) \cdot X_4 = X_2 X_3 X_4 X_5.
\end{align*}
Thus
\begin{equation}
\mathcal{S}_3 = \langle Z_1 Z_2 Z_3,\; Z_3 Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 X_5 \rangle .
\end{equation}

#### Step 4: \(\mathrm{CX}(q_4 \to q_5)\)

\begin{align*}
Z_1 Z_2 Z_3 &\to Z_1 Z_2 Z_3, \\
Z_3 Z_5 &\to Z_3 (Z_4 Z_5) = Z_3 Z_4 Z_5, \\
Z_2 Z_3 &\to Z_2 Z_3, \\
Z_3 Z_4 &\to Z_3 Z_4, \\
X_2 X_3 X_4 X_5 &\to X_2 X_3 (X_4 X_5) X_5 = X_2 X_3 X_4.
\end{align*}
Thus the final stabilizer group is
\begin{equation}
\mathcal{S}_{\mathrm{final}} =
\langle Z_1 Z_2 Z_3,\; Z_3 Z_4 Z_5,\; Z_2 Z_3,\; Z_3 Z_4,\; X_2 X_3 X_4 \rangle .
\end{equation}

#### Measurement analysis

From \(\mathcal{S}_{\mathrm{final}}\) we can have
\begin{itemize}
    \item \(Z_1 = (Z_1 Z_2 Z_3)(Z_2 Z_3) \in \mathcal{S}_{\mathrm{final}}\) \(\Rightarrow\) \(M_1 = Z_1\) is deterministic with outcome \(+1\).
    \item \(Z_5 = (Z_3 Z_4 Z_5)(Z_3 Z_4) \in \mathcal{S}_{\mathrm{final}}\) \(\Rightarrow\) \(M_2 = Z_5\) is deterministic with outcome \(+1\).
    \item \(Z_2 Z_3 = +1\) and \(Z_3 Z_4 = +1\) enforce \(m_3 \oplus m_4 = 0\) and \(m_4 \oplus m_5 = 0\), i.e., \(m_3 = m_4 = m_5\).  
          The individual values are random, but subject to these parity constraints.
\end{itemize}

These parity checks correspond to the two detectors \((m_3 \oplus m_4)\) and \((m_4 \oplus m_5)\) in the detector error model.

---

## The XP formalism

An XP stabiliser code is defined by fixing an integer \(N \geq 2\), referred to as the **precision** of the code.  
We take stabiliser generators from \(\langle \omega I, X, P \rangle^{\otimes n}\), where
\begin{equation}
    \omega := \exp\!\Big(\frac{\pi i}{N}\Big) = \exp\!\Big(\frac{1}{2N} 2\pi i\Big)
    \quad\text{so that}\quad
    \omega^{2N} = 1,
\end{equation}
and
\begin{equation}
    P:= \mathrm{diag}(1,\omega^2), \qquad P^N = I.
\end{equation}

Each choice of precision \(N\) leads to a different stabiliser formalism.  
For example, \(N = 2\) corresponds to the standard Pauli stabiliser formalism, with \(\omega = i\) and \(Z^2 = I\).

Under conjugation by Hadamard operators, if \(N = 2M\) then
\begin{equation}
    HPH^{-1} = \sqrt[M]{X}.
\end{equation}

### Vector representation of XP operators

Let \(\mathbf{u} = (p \mid \mathbf{X} \mid \mathbf{Z}) \in \mathbb{Z}_{2N} \times \mathbb{Z}_2^n \times \mathbb{Z}_N^n\)  
be an integer vector of length \(2n + 1\).  
The XP operator of precision \(N\) corresponding to \(\mathbf{u}\) is
\begin{equation}
    XP_N(\mathbf{u}) := \omega^p \bigotimes_{0 \leq i < n} X^{\mathbf{X}[i]} P^{\mathbf{Z}[i]}.
\end{equation}

Each component is periodic and can be rewritten as
\begin{equation}
    XP_N(p \mid \mathbf{X} \mid \mathbf{Z})
    = XP_N\big(p \bmod 2N \,\big|\, \mathbf{X} \bmod 2 \,\big|\, \mathbf{Z} \bmod N\big).
\end{equation}

Some useful properties:

1. The identity XP operator is \(XP_N(0 \mid \mathbf{0} \mid \mathbf{0})\), where \(\mathbf{0}\) is the length-\(n\) zero vector.
2. Because \(\omega^N = -1\), we have \(XP_N(N \mid \mathbf{0} \mid \mathbf{0}) = -I\).
3. The single-qubit \(X\) operator is \(XP_N(0 \mid 1 \mid 0)\).
4. Diagonal operators are of the form \(XP_N(N \mid \mathbf{0} \mid \mathbf{Z})\).
5. If \(N\) is even, the single-qubit \(Z\) operator is \(XP_N(0 \mid 0 \mid N/2)\).  
   For odd \(N\), \(Z\) operators cannot be represented as XP operators.

The XP formalism has a fundamental commutation relation that allows us to move \(P\) operators to the right of \(X\) operators:
\begin{equation}
    PX = \omega^2 X P^{-1}.
\end{equation}

The **action of an XP operator** on a computational-basis state \(\ket{\mathbf{e}}\),  
where \(\mathbf{e} \in \mathbb{Z}_2^n\), is
\begin{equation}
    XP_N(p \mid \mathbf{X} \mid \mathbf{Z}) \ket{\mathbf{e}}
    = \omega^{p + 2\mathbf{e} \cdot \mathbf{Z}} \ket{\mathbf{e} \oplus \mathbf{X}}.
\end{equation}

### Example: an XP operator at precision \(N = 8\)

Consider
\begin{equation}
    A = XP_8(12 \mid 1110000 \mid 0040000).
\end{equation}

The **precision** is specified by the subscript 8, so \(N = 8\).  
Then \(\omega = \exp\!\big(\tfrac{1}{16} 2\pi i\big)\) and \(P^8 = I\), so \(P = T\) where  
\(T = \mathrm{diag}(1, \sqrt{i})\).  
The overall phase of the operator is
\(\omega^{12} = \exp\!\big(\tfrac{12}{16} 2\pi i\big) = -i\).

The \(X\) component is a binary vector of length \(n\),  
so \(\mathbf{X} \in \mathbb{Z}_2^n\).  
In this case \(\mathbf{X} = 1110000\), representing \(X_1 X_2 X_3\).

The \(Z\) component is a vector \(\mathbf{Z} \in \mathbb{Z}_8^n\).  
Here \(\mathbf{Z} = 0040000\), representing \(T_3^4\).

Thus,
\begin{equation}
\begin{aligned}
    XP_8(12 \mid 1110000 \mid 0040000)
    &= \exp\!\Big(\frac{12}{16} 2\pi i\Big)\, X_1 X_2 X_3 T_3^4 \\
    &= -i\, X_1 X_2 X_3 Z_3 .
\end{aligned}
\end{equation}

Since the phase and \(Z\) components are divisible by \(4\),  
we can **rescale** \(A\) and write it as a precision-2 operator by dividing the phase and \(Z\) components by \(4\):
\begin{equation}
    XP_8(12 \mid 1110000 \mid 0040000)
    = XP_4(3 \mid 1110000 \mid 0010000).
\end{equation}